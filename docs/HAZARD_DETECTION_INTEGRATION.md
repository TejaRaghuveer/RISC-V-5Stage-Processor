# Hazard Detection Unit Integration Guide

This document explains how the hazard detection unit is integrated into the RISC-V 5-stage pipeline processor top-level module.

## Overview

The hazard detection unit detects **load-use data hazards** that cannot be resolved by forwarding. When a load instruction produces data needed by the immediately following instruction, the pipeline must be stalled for one cycle to allow the load to complete.

## Integration Points

### 1. Signal Declarations

```systemverilog
/**
 * Pipeline Control Signals (Internal)
 */
logic                              hazard_stall;            // Stall signal from hazard detection unit
logic                              hazard_id_ex_flush;      // ID/EX flush signal from hazard detection unit
logic                              pipeline_stall_internal;  // Combined stall signal (hazard + external)
logic                              pipeline_flush_internal;  // Combined flush signal (branch/jump + external + hazard)
```

**Explanation:**
- `hazard_stall`: Generated by hazard detection unit when load-use hazard detected
- `hazard_id_ex_flush`: Flush signal for ID/EX register to insert NOP bubble
- `pipeline_stall_internal`: Combines hazard stall with external stall
- `pipeline_flush_internal`: Combines branch/jump flush with external flush

### 2. Hazard Detection Unit Instantiation

```systemverilog
/**
 * Hazard Detection Unit Module
 * 
 * Detects load-use data hazards that cannot be resolved by forwarding.
 * When a load instruction in ID/EX stage produces data needed by the
 * instruction in ID stage, the pipeline must be stalled for one cycle.
 * 
 * Hazard Condition:
 * - Load instruction in ID/EX stage (ex_MemRead = 1)
 * - AND load's destination register (ex_rd_addr) matches rs1 or rs2
 *   of instruction in ID stage (id_rs1_addr or id_rs2_addr)
 * 
 * Pipeline Control Actions:
 * - Stall: Prevents PC update and holds IF/ID register
 * - Flush ID/EX: Inserts NOP/bubble in ID/EX register
 */
hazard_detection_unit hazard_detection_unit_inst (
    // Inputs from Pipeline Registers
    .id_ex_MemRead(ex_MemRead),          // Memory read enable from ID/EX register
    .id_ex_rd_addr(ex_rd_addr),           // Destination register address from ID/EX register
    .if_id_rs1_addr(id_rs1_addr),        // Source register 1 address from IF/ID register (via ID stage)
    .if_id_rs2_addr(id_rs2_addr),        // Source register 2 address from IF/ID register (via ID stage)
    
    // Outputs for Pipeline Control
    .stall(hazard_stall),                 // Pipeline stall signal (active high)
    .id_ex_flush(hazard_id_ex_flush)     // ID/EX register flush signal (active high)
);
```

**Key Connections:**
- **Inputs**: 
  - `id_ex_MemRead`: Indicates if instruction in EX stage is a load
  - `id_ex_rd_addr`: Destination register of load instruction
  - `if_id_rs1_addr`, `if_id_rs2_addr`: Source registers of instruction in ID stage
- **Outputs**:
  - `stall`: Stall signal (active high) to prevent PC and IF/ID updates
  - `id_ex_flush`: Flush signal (active high) to insert NOP in ID/EX register

### 3. Combined Stall Signal Generation

```systemverilog
/**
 * Combined Pipeline Stall Signal Generation
 * 
 * Combines hazard stall with external stall signal.
 * Pipeline stalls when:
 * - Load-use hazard detected (hazard_stall = 1), OR
 * - External stall requested (pipeline_stall = 1)
 * 
 * Stall Behavior:
 * - Prevents PC from updating (PC holds current value)
 * - Prevents IF/ID register from updating (holds current instruction)
 * - Causes pipeline bubble in IF and ID stages
 * - Used for data hazards that cannot be resolved by forwarding
 */
assign pipeline_stall_internal = hazard_stall || pipeline_stall;
```

**Explanation:**
- Combines internal hazard stall with external stall signal
- Pipeline stalls if either condition is true
- Allows external control (e.g., cache miss, external interrupt) to also stall pipeline

### 4. PC Stall Connection (IF Stage)

```systemverilog
if_stage #(
    .DATA_WIDTH(DATA_WIDTH),
    .ADDR_WIDTH(ADDR_WIDTH),
    .IMEM_DEPTH(IMEM_DEPTH),
    .IMEM_ADDR_WIDTH(IMEM_ADDR_WIDTH)
) if_stage_inst (
    .clk(clk),
    .rst_n(rst_n),
    .branch_target(branch_target),
    .branch_taken(branch_taken),
    .stall(pipeline_stall_internal),     // Pipeline stall signal (hazard + external)
    .flush(pipeline_flush_internal),
    // ... other connections
);
```

**Stall Behavior:**
- When `stall = 1`: PC register holds current value (doesn't increment)
- Prevents fetching new instruction
- IF stage outputs remain unchanged

### 5. IF/ID Register Enable Connection

```systemverilog
if_id_reg #(
    .DATA_WIDTH(DATA_WIDTH),
    .ADDR_WIDTH(ADDR_WIDTH)
) if_id_reg_inst (
    .clk(clk),
    .rst_n(rst_n),
    .enable(~pipeline_stall_internal),  // Enable when not stalled (active low: ~stall)
    .flush(pipeline_flush_internal),
    // ... other connections
);
```

**Enable Signal Behavior:**
- `enable` is **active low** (0 = disabled, 1 = enabled)
- When `pipeline_stall_internal = 1`: `enable = 0` → register holds current values
- When `pipeline_stall_internal = 0`: `enable = 1` → register updates normally
- **Note**: The `~` (NOT) operator inverts the stall signal because enable is active low

### 6. ID/EX Register Flush Connection

```systemverilog
id_ex_reg #(
    .DATA_WIDTH(DATA_WIDTH),
    .ADDR_WIDTH(ADDR_WIDTH)
) id_ex_reg_inst (
    .clk(clk),
    .rst_n(rst_n),
    .enable(~pipeline_stall_internal),    // Enable when not stalled (active low: ~stall)
    .flush(pipeline_flush_internal || hazard_id_ex_flush), // Flush: branch/jump + external + hazard NOP insertion
    // ... other connections
);
```

**Flush Signal Behavior:**
- `flush` is **active high** (1 = flush, 0 = normal)
- When `hazard_id_ex_flush = 1`: ID/EX register cleared (NOP inserted)
- Combines with branch/jump flush and external flush
- **Purpose**: Inserts pipeline bubble to prevent load instruction from entering EX stage

## Pipeline Stall Flow Diagram

```
Load-Use Hazard Detected:
┌─────────────────────────────────────────────────────────────┐
│ Cycle N:                                                    │
│   IF:  Fetch instruction I+2                               │
│   ID:  Decode instruction I+1 (needs data from load)        │
│   EX:  Load instruction I (lw x1, 0(x2))                   │
│   MEM: Previous instruction                                 │
│   WB:  Previous instruction                                 │
│                                                              │
│   Hazard Detection:                                         │
│   - ex_MemRead = 1 (load in EX stage)                       │
│   - ex_rd_addr = x1                                         │
│   - id_rs1_addr = x1 (instruction I+1 needs x1)            │
│   → hazard_stall = 1                                        │
│   → hazard_id_ex_flush = 1                                  │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ Cycle N+1: (Stall Cycle)                                    │
│   IF:  PC holds (stall = 1)                                 │
│   ID:  Same instruction I+1 (IF/ID holds)                   │
│   EX:  NOP inserted (ID/EX flushed)                         │
│   MEM: Load instruction I (accesses memory)                 │
│   WB:  Previous instruction                                 │
│                                                              │
│   Pipeline Control:                                         │
│   - PC doesn't update (stall prevents increment)            │
│   - IF/ID register holds instruction I+1                   │
│   - ID/EX register cleared (NOP inserted)                    │
│   - Load completes memory access                             │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ Cycle N+2: (Resume)                                         │
│   IF:  Fetch instruction I+2 (PC resumes)                   │
│   ID:  Decode instruction I+1 (can now read x1)            │
│   EX:  Instruction I+1 executes (data available)            │
│   MEM: Load instruction I (writes x1 in WB stage)            │
│   WB:  Load writes x1 to register file                     │
│                                                              │
│   Hazard Resolved:                                          │
│   - hazard_stall = 0                                        │
│   - Pipeline resumes normal operation                       │
└─────────────────────────────────────────────────────────────┘
```

## Signal Timing

### Stall Signal Timing:
1. **Detection** (Combinational): Hazard detected based on current pipeline state
2. **Assertion** (Next Clock Edge): Stall signal takes effect
   - PC holds current value
   - IF/ID register holds current instruction
3. **Resolution** (One Cycle Later): Load completes, stall deasserted
   - PC resumes incrementing
   - IF/ID register updates with new instruction

### Flush Signal Timing:
1. **Detection** (Combinational): Hazard detected, flush signal generated
2. **Assertion** (Next Clock Edge): ID/EX register cleared
   - Control signals set to safe defaults (NOP)
   - Prevents load from entering EX stage
3. **Effect**: Pipeline bubble inserted, allowing load to complete

## Key Design Decisions

### 1. Why Stall PC and IF/ID?
- **PC Stall**: Prevents fetching new instruction that would also need to wait
- **IF/ID Hold**: Keeps current instruction in ID stage so it can proceed once data is available
- **Result**: One-cycle stall allows load to complete before dependent instruction executes

### 2. Why Flush ID/EX?
- **NOP Insertion**: Prevents load instruction from entering EX stage during stall
- **Bubble Creation**: Creates pipeline bubble that allows load to complete
- **Control Signal Safety**: Cleared control signals prevent incorrect operations

### 3. Why Combine Stall Signals?
- **External Control**: Allows external modules (cache, interrupt controller) to stall pipeline
- **Flexibility**: Supports multiple stall sources
- **Priority**: Any stall source can halt pipeline

### 4. Why Separate Flush Signals?
- **Selective Flushing**: Hazard flush only affects ID/EX register
- **Branch Flush**: Affects IF/ID and ID/EX registers (different scope)
- **Modularity**: Each flush source can be controlled independently

## Testing Considerations

When testing the hazard detection unit integration:

1. **Load-Use Hazard Test**:
   ```assembly
   lw x1, 0(x2)    ; Load instruction
   add x3, x1, x4  ; Uses x1 immediately (hazard!)
   ```
   - Verify: Pipeline stalls for 1 cycle
   - Verify: PC doesn't increment during stall
   - Verify: IF/ID register holds "add" instruction
   - Verify: ID/EX register contains NOP during stall

2. **No Hazard Test**:
   ```assembly
   lw x1, 0(x2)    ; Load instruction
   add x3, x5, x4  ; Doesn't use x1 (no hazard)
   ```
   - Verify: Pipeline operates normally
   - Verify: No stall signal asserted

3. **Forwarding vs. Stalling**:
   ```assembly
   add x1, x2, x3  ; ALU instruction
   add x4, x1, x5  ; Uses x1 (forwarding resolves)
   ```
   - Verify: No stall (forwarding handles this)
   - Verify: Data forwarded from EX/MEM stage

## Summary

The hazard detection unit integration provides:
- **Automatic Load-Use Detection**: Detects hazards without programmer intervention
- **Pipeline Stall Control**: Prevents incorrect execution by stalling pipeline
- **NOP Insertion**: Inserts pipeline bubbles to maintain pipeline integrity
- **External Interface**: Supports external stall/flush signals for system integration
- **Performance**: Minimal overhead (1-cycle stall per load-use hazard)

The integration ensures correct execution of load instructions while maintaining pipeline performance through forwarding for other data hazards.

